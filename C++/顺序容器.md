## 顺序容器类型
|类型|说明|
|:----|:----|
|`vector`|可改变大小数组。支持快速随机访问。在尾部之外的位置插入或删除元素可能很慢|
|`deque`|双端队列。支持快速随机访问。在头尾位置插入、删除很快|
|`list`|双向链表。只支持双向顺序访问。在 `list` 中任何位置进行插入、删除操作都很快|
|`forward_list`|单向链表。只支持单向顺序访问。在链表中任何位置进行插入、删除操作都很快|
|`array`|固定大小数组。支持快速随机访问。不能添加或删除元素|
|`string`|与 `vector` 相似的容器。随机访问快。在尾部插入、删除速度快|

C11 新增 `array` 和 `forward_list`。`array` 是以中更安全、更容易使用的数组类型。与数组相似，它的大小固定，所以它不支持添加删除元素，更不能改变容器大小

### 确定使用哪种顺序容器
>通常，使用 `vector` 是最好的选择

一些基本原则：
- 除非你有更好的理由选择其他的容器，否则应用 vector
- 如果你的程序有 *很多小元素* ，且空间的额外开销很重要，则<u>不要</u>使用 list 或 forward_list
- 如果程序要求随机访问元素，应使用 vector 或 deque
- 如果程序要求在 *容器的中间插入或删除元素*，应使用 list 或 forward_list
- 如果要求在 *头尾位置插入或删除元素*，但 *不会在中间进行插入或删除操作*，则使用 deque
- 如果只有在读取输入的时候才需要在容器中间插入元素，随后需要随机访问元素，则
	- 如果不需要在中间添加元素，在输入的阶段使用 vector 进行追加元素，然后使用 sort 来重排容器中的元素，从而避免在中间位置添加元素
	- 如果需要在中间添加，考虑在输入阶段使用 list ，一旦，输入完成，将 list 中的内容拷贝到一个 vector 中

一般来说，应用中主导地位的操作决定了容器类型选择类型

## 容器库概览
### 迭代器
正向迭代器

|迭代器|说明|
|:----|:----|
|`iterator`|此容器的迭代器类型|
|`cosnt_iterator`|可以读取但不能修改的迭代器|
|`c.begin()`,`c.end()`|返回首元素与尾元素迭代器|
|`c.cbegin()`,`c.cend()`|同上，但类型为 `cosnt_iterator`|

反向迭代器（不适用 `forward_list`）

|迭代器|说明|
|:----|:----|
|`reverse_iterator`|按逆序寻址元素的迭代器|
|`cosnt_reverse_iterator`|可以读取但不能修改的迭代器|
|`c.rbegin()`,`c.rend()`|返回 <u>尾元素</u> 与 <u>首元素</u> 迭代器|
|`c.crbegin()`,`c.crend()`|同上，但类型为 `cosnt_reverse_terator`|

反向迭代器依然是使用 ++ 操作会得到上一个迭代器

>当不需要读写操作时，应该使用 `cbegin` 和 `cend`

#### 迭代器范围
迭代器范范围由一对迭代器表示
迭代器的范围是左闭右开的区间（关于 `end()`[标准库类型-迭代器简介](标准库类型.md)）

### 容器类型成员
|成员|说明|
|:----|:----|
|`size_type`|无符号整型数，足够保存容器的大小|
|`difference_type`|带符号整数型，足够保存两迭代器之间的距离|
|`value_type`|元素类型|
|`reference`|元素的左值类型：与 `value_type&` 含义相同|
|`const_reference`|同上，但类型为 `cosnt value_type&`|

### 容器定义与初始化
C11 新的列表初始化
```c++
list<string> str = {"a", "As", "asas"};
```

接受两个迭代器参数的构造函数表示拷贝的一个范围（依然是左闭右开）
```c++
list<string> str(iterator_1, iterator_2);
```

>只有顺序容器才接受大小参数，关联容器并不支持

#### 标准库 array 具有固定大小
当定义一个 `array` 时，除了指定元素的类型，还要指定容器的大小：
```c++
array<int, 4>;
```

使用 `array` 类型时必须同时指定元素类型和大小：
```c++
array<int, 4>::size_type i;
```

`array` 可以进行拷贝或对象赋值操作：
```c++
array<int, 10> digits = {...};
array<int, 10> d_copy = digits;
```

### 赋值和 swap
>赋值相关运算会导致直向左边容器内部的迭代器、引用和指针失效。而 `swap` 则不会导致以上情况（`array` 和 `string` 除外）

#### assign（只用于顺序容器）
|操作|说明|
|:----|:----|
|`seq.assign(b, e)`|将 *seq* 中的元素替换为迭代器 *b* 和 *e* 所表示范围中的元素|
|`seq.assign(il)`|将 *seq* 中的元素替换为初始化列表 *il* 中的元素|
|`seq.assign(n, t)`|将 *seq* 中的元素替换为 n 个值为 t 的元素|

赋值运算符要求左边和右边的运算对象具有相同的类型。顺序容器中的 `assign` 成员允许我们从一个**不同但相容的类型赋值**，或者从容器的一个子序列赋值。`assign` 操作用参数所指定的元素（的拷贝）替换左边容器中的所有元素
```c++
list<string> names;
vector<const char*> oldstyle;
names.assign(oldstyle.cbegin(), oldstyle.cend());

// 替换指定数目的相同元素
list<string> slist1(1);
slist1.assign(10,"hiya!");
```

>由于旧元素被替换，因此传递给 `assign` 的迭代器不能指向调用 `assign` 的容器


#### swap
`swap` 操作交换两个相同类型容器的内容

|操作|说明|
|:----|:----|
|`swap(c1, c2)`|交换 *c1* 和 *c2* 中的元素，*c1* 和 *c2* 必须具有相同的类型|
|`c1.swap(c2)`|同上|

除 `array` 外，`swap` 不对任何元素进行拷贝、删除或插入操作，因此可以保证在常数时间内完成
除 `string` 以外，`swap` 操作不会使迭代器、引用和指针失效
假如在 `swap` 之前指定了一个迭代器指向了 *svec1[3]*，那么交换后它所指向的应该是*svec2[3]* 的值
然而 `array` 是真正交换了元素

## 顺序容器的操作
### 添加元素
- `forward_list` 有自己专有版本的 `insert` 和 `emplace`，并且不支持 `push_back` 和 `emplace_back`
- `vector` 和 `string` 不支持 `push_front` 和 `emplace_front`

|操作|说明|
|:----|:----|
|`c.push_back(t)`|在 *c* 的尾部创建一个值为 *t* 或 *args* 创建的元素。返回 `void`|
|`c.emplace_back(args)`|同上|
|`c.push_front(t)`|在 *c* 的头部创建一个值为 *t* 或 *args* 创建的元素。返回 `void`|
|`c.emplace_front(args)`|同上|
|`c.insert(p, t)`|在迭代器 *p* 指向的元素之前创建一个值为 *t* 或有 *args* 创建的元素。<br>返回指向新添加元素的叠加器|
|`c.emplace(p, args)`|同上|
|`c.insert(p, n, t)`|在迭代器 *p* 指向的元素之前插入 *n* 个值为 *t* 的元素。<br>返回指向新添加的 *第一个* 元素的叠加器；若 *n* 为 0，则返回 *p*|
|`c.insert(p, b, e)`|将迭代器 *b* 和 *e* 指定的范围内的元素插入到迭代器 *p* 指向的元素之前。<br>*b* 和 *e* 不能指向 *c* 中的元素。返回指向新添加的 *第一个* 元素的叠加器；若范围为 0，则返回 *p*|
|`c.insert(p. il)`|*il* 是花括号包围的元素值列表，插入同上，返回同上|

>向一个 `vector`、`string` 或 `deque` 插入元素会使所有指向容器的迭代器、引用和指针失效
>容器元素是拷贝：将一个对象插入到容器时，实际上放入的是对象的一个拷贝，而不是对象的本身

`deque` 像 `vector` 一样提供了**随机访问**的能力，但他提供了 `psuh_front()`。`deque` 保证在容器首尾进行操作的时候只需花费常数级的时间

#### emplace
C11 新标准
- `emplace_front`：同等于 `push_front`
- `emplace`：同等于 `insert`
- `emplace_back`：同等于 `push_back`

`emplace` 与它们同等的成员不相同：当我们调用一个 `emplace` 成员函数时，则是将参数传递给元素类型的构造函数。`emplace` 成员使用这些参数在容器管理的内存空间中直接构造函数：
```c++
// 在 c 的末尾构造一个 Sales_data 对象
c.emplace_back("99999", 25, 15.99);
```

同等的成员函数会创建一个局部临时变量，并将其压入容器中

### 访问元素
- `at` 和下标操作只适用于 `string`，`vector`，`deque` 和 `array`
- `back` 不适用于 `forward_list`

|操作|说明|
|:----|:----|
|`c.back()`|返回 *c* 中尾元素的引用。若 *c* 为空，函数行为未定义|
|`c.front()`|返回 *c* 中首元素的引用。若 *c* 为空，函数行为未定义|
|`c[n]`|下标操作返回引用|
|`c.at(n)`|返回下标为 *n* 的元素引用。如果下标越界，则抛出 `out_of_range` 异常|

#### 访问成员函数返回的是引用
在容器中访问元素的成员返回的都是该元素的引用。如果一个容器为 `const` 对象，则返回的是 `const` 的引用
改变元素的值：
```c++
if(!c.empty()){
	// 将 42 赋予 c 中的第一个元素
	c.front() = 42;
	// 获得 c 中最后一个元素的引用
	auto &v = c.back();
	v = 1012;
}
```

如果不是引用类型则获得的是该元素的拷贝

### 删除元素
- 不适用于 `array`
- `forward_list` 有特殊的 `erase`
- `forward_list` 不支持 `pop_back`
- `vector` 和 `string` 不支持 `pop_front`

|操作|说明|
|:----|:----|
|`c.pop_back()`|删除 *c* 中尾元素|
|`c.pop_front()`|删除 *c* 中首元素|
|`c.erase(p)`|删除迭代器 *p* 所指定的元素，返回一个指向被删除元素之后元素的迭代器，<br>若 *p* 指向尾元素，则返回尾后迭代器|
|`c.erase(b, e)`|删除迭代器 *b* 和 *e* 所指定范围内的元素。返回一个指向被删除元素之后元素的迭代器，<br>若 *e* 本身就是尾后迭代器，则函数也返回尾后迭代器|
|`c.clear()`|删除 *c* 中所有的元素|

>删除 `deque` 中除首尾位置之外的任何元素都会使所有迭代器、引用和指针失效。指向 `vector` 和 `string` 中 ***删除点之后*** 的迭代器、引用和指针都会失效
>删除元素的成员函数并不会检查其参数。所以在删除元素之前必须确保它们是存在的

`erase` 不论是单个删除还是范围删除返回值都会指向最后一个被删除元素之后的迭代器，若迭代器为尾后迭代器，则函数也返回尾后迭代器

### 特殊的 forward_list 操作
在 `forward_list` 中添加或删除元素的操作是通过改变给定元素之后的元素来完成的，这样才可以访问到添加或删除操作所影响的元素

|操作|说明|
|:----|:----|
|`lst.before_begin()`|返回指向链表首元素之前 *不存在* 的元素迭代器。**此迭代器不能解引用**。|
|`lst.cbefore_begin()`|同上，返回 `const_iterator`|
|`lst.insert_after(p, t)`|在迭代器 *p* 之后的位置插入元素。*t* 是一个对象|
|`lst.insert_after(p, n, t)`|同上，*n* 是数量|
|`lst.insert_after(p, b, e)`|*b* 和 *e* 表示迭代器的范围|
|`lst.insert_after(p, il)`|*il* 是一个花括号列表|
|`emplace_after(p, args)`|使用 *args* 在 *p* 指定的位置之后创建一个元素。返回这个新元素的迭代器。<br>若 *p* 为尾后迭代器，则函数行为未定义|
|`lst.erase_after(p)`|删除 *p* 指向的位置之后的元素|
|`lst.erase_after(b, e)`|删除从 *b* 之后直到 *e* 之间的元素|

`insert_after(p,...)` 返回一个指向最后插入元素的迭代器。如果范围为空，则返回 *p*。若 *p* 为尾后迭代器，则该函数行为未定义
`erase_after` 返回一个指向被删除元素之后的元素的迭代器，若不存在这样的元素，则返回尾后迭代器。若 *p* 指向尾后迭代器或者尾院素，则函数行为未定义

### 改变容器的大小
- `resize` 不适用于 `array`

|操作|说明|
|:----|:----|
|`c.resize(n)`|调整 *c* 的大小为 *n* 个元素。若 *n*<*c.size()*，则多出的元素被丢弃|
|`c.resize(n, t)`|同上，新添加的元素会被初始化为 *t*|

>使用 `resize` 缩小容器，则会使容器迭代器、引用和指针都会失效；对 `vector`，`string` 或 `deque` 进行`resize` 可能会导致上述情况

### 容器操作可能使迭代器失效
向容器添加或删除元素都会可能导致迭代器失效
添加元素后：
- 对于`vector` 或 `string`：如果存储空间被重新分配，则指向容器的迭代器、指针和引用将会失效；若存储空间未进行重新分配，那么只想插入前的迭代器（...）都不会失效，只想后面的会发生失效
- 对于 `deque` ：插入到首尾位置之外的任何位置都会使迭代器（...）失效。如果在首尾位置添加元素，迭代器会失效，但是指向存在元素的指针和引用均不会失效
- 对于 `list` 和 `forward_list` 均有效

删除元素后：
- 对于 `list` 和 `forward_list` ，指向容器其他位置的迭代器（...）均有效
- 对于 `deque`：如果在首尾之外的任何位置删除元素，那么指向被删除元素外其他元素的迭代器（...）都会失效；如果删除尾元素，尾后迭代器会失效，其他则不受影响；如果删除首元素，这些也不会受到影响
- 对于 `vector` 和 `string`：指向被删除元素之前元素的迭代器（...）依然有效。当我们删除元素时，尾后迭代器总是会失效

>为了保证迭代器依然有效，应当在每次改变容器操作之后重新定位迭代器

## vector 对象是如何增长的
`vector` 和 `string` 的实现通常会比新的空间需求更大的内存空间，容器预留这些空间作为备用，这样就可以不需要在每次添加元素时重新分配容器的内存空间

### 管理容量的成员函数
- `shrink_to_fit` 只适用于 `vector`，`string` 和 `deque`
- `capacity` 和 `reserve` 只适用于 `vector` 和 `string`

|操作|说明|
|:----|:----|
|`c.capacity()`|不重新分配空间的话，*c* 可以保存多少个元素|
|`c.shrink_to_fit()`|将 `capacity` 减少为与 `size()` 相同的大小|
|`c.reserve(n)`|分配至少能容纳 *n* 个元素的内存空间|

>`reserve` 并不会改变容器中元素的数量，它仅影响 `vector` 预先分配多大的内存空间

只有当需要的内存空间超过当前容量时，`reserve`  调用才会改变 `vector` 的容量；如果需求小于或等于当前容量，`reserve` 什么都不会做，**并且不会退回内存空间**。因此，在调用 `reserve` 之后，`capacity` 将会大于或等于传递给 `reserve` 的参数

C11 新标准中，可以调用 `shrink_to_fit` 来要求 `vector`，`string` 和 `deque` 来退回不需要的内存空间

#### capacity 和 size
两者不是同一个意思！
两者不是同一个意思！
两者不是同一个意思！

## 额外的 string 操作
### 构造 string 的其他方法
- *n*，*len2* 和 *pos2* 都是无符号值

|操作|说明|
|:----|:----|
|`string s(cp, n)`|*s* 是 *cp* 指向的**数组**中前 *n* 个字符的拷贝。此数组至少应该包含 *n* 个字符|
|`string s(s2, pos2)`|*s* 是 *string s2* 从下标 *pos2* 开始的字符拷贝。*pos2* 应当小于 *s2.size()*|
|`string s(s2, pos2, len2)`|*s* 是 *string s2* 从下标 *pos2* 开始 *len2* 个字符拷贝。*pos2* 应当小于 *s2.size()*，<br>构造函数最多拷贝 *s2.size() - pos2* 个字符 |

这些构造函数接受一个 `string` 或一个 `const char*` 参数，通常我们从一个 `const char*` 创建 `string` 时，指针指向的数组必须以空字符结尾，拷贝操作遇到空字符时停止

超出范围返回 `out_of_range`

### substr 操作

|操作|说明|
|:----|:----|
|`s.substr(pos, n)`|返回 `string` ，包含 *s* 中从 *pos* 开始的 *n* 个字符拷贝。*pos* 默认值为 0，*n* 默认值为 *s.szie()-pos*|

超出范围返回 `out_of_range`

### 改变 string 的其他方法
`string` 提供了额外的 `insert` 和 `erase` 版本（使用下标）

```c++
// 在 s 末尾插入 5 个感叹号
s.insert(s.size(), 5, '!');
// 删除 s 最后 5 个字符
s.erase(s.size() - 5, 5);
```

C风格字符串版本的 `insert` 和 `assign` 
```c++
const char *cp = "XXYZ";
// s == "XX"
s.assign(cp, 2);
// s == "XXYZ"
s.insert(s.size(), cp + 2);
```

#### append 和 replace 函数
`append` 是在 `string` 末尾进行插入操作的一种简写形式；`replace` 操作是调用 `erase` 和 `insert` 的一种简写形式

|操作|说明|
|:----|:----|
|`s.insert(pos, args)`|在 *pos* 之前插入 *args* 指定的字符。*pos* 可以为下标也可以为迭代器。<br>下标版本返回对 *s* 的引用；迭代器版本返回指向第一个插入字符的迭代器|
|`s.erase(pos, len)`|删除从位置 *pos* 开始的 *len* 个字符。如果 *len* 被省略，则删除从 *pos* 开始到结尾的所欲所有字符。返回一个指向 *s* 的引用|
|`s.assign(args)`|分配至少能容纳 *n* 个元素的内存空间|
|`s.append(args)`||
|`s.replace(range, args)`||
