## 顺序容器类型
|类型|说明|
|:----|:----|
|`vector`|可改变大小数组。支持快速随机访问。在尾部之外的位置插入或删除元素可能很慢|
|`deque`|双端队列。支持快速随机访问。在头尾位置插入、删除很快|
|`list`|双向链表。只支持双向顺序访问。在 `list` 中任何位置进行插入、删除操作都很快|
|`forward_list`|单向链表。只支持单向顺序访问。在链表中任何位置进行插入、删除操作都很快|
|`array`|固定大小数组。支持快速随机访问。不能添加或删除元素|
|`string`|与 `vector` 相似的容器。随机访问快。在尾部插入、删除速度快|

C11 新增 `array` 和 `forward_list`。`array` 是以中更安全、更容易使用的数组类型。与数组相似，它的大小固定，所以它不支持添加删除元素，更不能改变容器大小

### 确定使用哪种顺序容器
>通常，使用 `vector` 是最好的选择

一些基本原则：
- 除非你有更好的理由选择其他的容器，否则应用 vector
- 如果你的程序有 *很多小元素* ，且空间的额外开销很重要，则<u>不要</u>使用 list 或 forward_list
- 如果程序要求随机访问元素，应使用 vector 或 deque
- 如果程序要求在 *容器的中间插入或删除元素*，应使用 list 或 forward_list
- 如果要求在 *头尾位置插入或删除元素*，但 *不会在中间进行插入或删除操作*，则使用 deque
- 如果只有在读取输入的时候才需要在容器中间插入元素，随后需要随机访问元素，则
	- 如果不需要在中间添加元素，在输入的阶段使用 vector 进行追加元素，然后使用 sort 来重排容器中的元素，从而避免在中间位置添加元素
	- 如果需要在中间添加，考虑在输入阶段使用 list ，一旦，输入完成，将 list 中的内容拷贝到一个 vector 中

一般来说，应用中主导地位的操作决定了容器类型选择类型

## 容器库概览
### 迭代器
正向迭代器

|迭代器|说明|
|:----|:----|
|`iterator`|此容器的迭代器类型|
|`cosnt_iterator`|可以读取但不能修改的迭代器|
|`c.begin()`,`c.end()`|返回首元素与尾元素迭代器|
|`c.cbegin()`,`c.cend()`|同上，但类型为 `cosnt_iterator`|

反向迭代器（不适用 `forward_list`）

|迭代器|说明|
|:----|:----|
|`reverse_iterator`|按逆序寻址元素的迭代器|
|`cosnt_reverse_iterator`|可以读取但不能修改的迭代器|
|`c.rbegin()`,`c.rend()`|返回 <u>尾元素</u> 与 <u>首元素</u> 迭代器|
|`c.crbegin()`,`c.crend()`|同上，但类型为 `cosnt_reverse_terator`|

反向迭代器依然是使用 ++ 操作会得到上一个迭代器

>当不需要读写操作时，应该使用 `cbegin` 和 `cend`

#### 迭代器范围
迭代器范范围由一对迭代器表示
迭代器的范围是左闭右开的区间（关于 `end()`[标准库类型-迭代器简介](标准库类型.md)）

### 容器类型成员
|成员|说明|
|:----|:----|
|`size_type`|无符号整型数，足够保存容器的大小|
|`difference_type`|带符号整数型，足够保存两迭代器之间的距离|
|`value_type`|元素类型|
|`reference`|元素的左值类型：与 `value_type&` 含义相同|
|`const_reference`|同上，但类型为 `cosnt value_type&`|

### 容器定义与初始化
C11 新的列表初始化
```c++
list<string> str = {"a", "As", "asas"};
```

接受两个迭代器参数的构造函数表示拷贝的一个范围（依然是左闭右开）
```c++
list<string> str(iterator_1, iterator_2);
```

>只有顺序容器才接受大小参数，关联容器并不支持

#### 标准库 array 具有固定大小
当定义一个 `array` 时，除了指定元素的类型，还要指定容器的大小：
```c++
array<int, 4>;
```

使用 `array` 类型时必须同时指定元素类型和大小：
```c++
array<int, 4>::size_type i;
```

`array` 可以进行拷贝或对象赋值操作：
```c++
array<int, 10> digits = {...};
array<int, 10> d_copy = digits;
```

### 赋值和 swap
>赋值相关运算会导致直向左边容器内部的迭代器、引用和指针失效。而 `swap` 则不会导致以上情况（`array` 和 `string` 除外）

#### assign（只用于顺序容器）
|操作|说明|
|:----|:----|
|`seq.assign(b, e)`|将 *seq* 中的元素替换为迭代器 *b* 和 *e* 所表示范围中的元素|
|`seq.assign(il)`|将 *seq* 中的元素替换为初始化列表 *il* 中的元素|
|`seq.assign(n, t)`|将 *seq* 中的元素替换为 n 个值为 t 的元素|



#### swap