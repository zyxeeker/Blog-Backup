##
定义在类内部的函数隐式的 `inline` 函数
## this
### 返回  this 对象的函数
```c++
Sale_data& Sales_data::combine(const Sales_data &rhs) {
	units_sold += rhs.units_sold;
	return *this;
}
```

## 定义类相关的非成员函数
用来定义一些辅助函数，比如 *add*，*read*，*print* 等等
>如果非成员函数是类接口的组成部分，则这些函数的声明应该与类在同一头文件内

### 定义 read 和 print 函数（书上的例子）
```c++
istream &read(istream &is, Sales_data &item) {
	double price = 0;
	is >> item.bookNo >> item.unit_sold >> price;
	return is;
}

ostream &print(ostream &os. const Sales_data &item) {
	os << item.isbn() << " " << item.units_sold << " " 
	   << item.revenue << " " << item.avg_price();
	return os;
}
```

- *read* 和 *print*分别接受一个各自类型的引用作为其参数，这是因为 IO 类属于不能被拷贝的类型，因此只能通过传递引用来传递它们
- *print* 函数不负责换行，一般由用户代码来决定还是是否换行

### 定义 add 函数（书上的例子）
```c++
Sales_data add(const Sales_data &lhs, const Sales_data &rhs) {
	Sales_data sum = lhs;
	sum.combine(rhs);
	return sum;
};
```

## 构造函数
### 默认构造函数
并不是所有的类都可以使用默认构造函数进行初始化，有些自定义的复合类型就不能进行默认初始化

```c++
struct Sales_data {
	Sales_data() = default;
	...
};
```

#### = default 的含义
默认构造函数，在 C11 中如果我们需要默认的行为，那么可以通过在参数列表后面写上 `= default` 来要求编译器生成构造函数

### 构造函数初始值列表
```c++
Sales_data(const std::string &s) : bookNo(s) {}
```

>构造函数不应该轻易覆盖掉类内的初始值，除非新赋的值与原值不同

## struct 与 class
出于统一编程风格的考虑，当我们希望定义的类所有的成员是 `public` 的时，使用 `struct` ；反之，则使用 `private`

>使用 `class` 和 `struct` 定义类唯一的区别就是默认的访问权限

## 友元
关键字为 `friend`
如果类想把一个函数作为它的友元，只需要添加一条以 `friend` 关键字开始的函数声明语句即可：
```c++
class Sales_data {
	friend Sales_data add(const Sales_data&, const Sales_data&);
	friend std::istream &read(std::istream&, Sales_data&);
	frieng std::ostream &print(std::ostream&, const Sales_data&);
	...
};
```

友元不是类的成员也不受他所在区域访问控制级别的约束
>一般来说，最好是在雷丁一开始或结束前的位置集中声明友元
---
>封装的益处：
>- 确保用户代码不会无意间破坏封装对象的状态
>- 被封装的类的具体实现细节可以随时改变，而无需调整用户级别的代码

---

## 类的其他特性
### 定义一个类型成员
类型成员通常出现在类开始的地方
```c++
class Screen {
public:
	typedef std::string::size_type pos;
private:
	pos cursor = 0;
	pos height = 0, width = 0;
	std::string contents;
};
```

```c++
typedef std::string::size_type pos;
```

等价于
```c++
using pos = std::string::size_t;
```

### 可变数据成员
我们希望在能修改类的某个数据成员，即使是在一个常量成员函数内
关键字为 `mutable` 
一个可变数据成员永远不会是 `const` ，即使他是 `const` 对象。因此，一个常量长远函数可以该百年一个可变成员的值
```c++
class Screen {
public:
	void some_member() const;
private:
	mutable size_t access_ctr;
};

void Screen::some_member() const{
	++access_str;
}
```

