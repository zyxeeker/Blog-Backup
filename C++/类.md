定义在类内部的函数是隐式的 `inline` 函数
## this
### 返回  this 对象的函数
```c++
Sale_data& Sales_data::combine(const Sales_data &rhs) {
	units_sold += rhs.units_sold;
	return *this;
}
```

## 定义类相关的非成员函数
用来定义一些辅助函数，比如 *add*，*read*，*print* 等等
>如果非成员函数是类接口的组成部分，则这些函数的声明应该与类在同一头文件内

### 定义 read 和 print 函数（书上的例子）
```c++
istream &read(istream &is, Sales_data &item) {
	double price = 0;
	is >> item.bookNo >> item.unit_sold >> price;
	return is;
}

ostream &print(ostream &os. const Sales_data &item) {
	os << item.isbn() << " " << item.units_sold << " " 
	   << item.revenue << " " << item.avg_price();
	return os;
}
```

- *read* 和 *print*分别接受一个各自类型的引用作为其参数，这是因为 IO 类属于不能被拷贝的类型，因此只能通过传递引用来传递它们
- *print* 函数不负责换行，一般由用户代码来决定还是是否换行

### 定义 add 函数（书上的例子）
```c++
Sales_data add(const Sales_data &lhs, const Sales_data &rhs) {
	Sales_data sum = lhs;
	sum.combine(rhs);
	return sum;
};
```

## 构造函数
### 默认构造函数
并不是所有的类都可以使用默认构造函数进行初始化，有些自定义的复合类型就不能进行默认初始化

```c++
struct Sales_data {
	Sales_data() = default;
	...
};
```

#### = default 的含义
默认构造函数，在 C11 中如果我们需要默认的行为，那么可以通过在参数列表后面写上 `= default` 来要求编译器生成构造函数

### 构造函数初始值列表
```c++
Sales_data(const std::string &s) : bookNo(s) {}
```

>构造函数不应该轻易覆盖掉类内的初始值，除非新赋的值与原值不同
---
>建议：使用构造函数初始值来进行初始化
>初始化和赋值的区别事关底层效率的问题：前者直接初始化数据成员，后者则是先初始化再赋值
---

**如果成员是 `const` 、引用，或者属于某种未提供默认构造函数地类类型，我们必须将他们初始化，而且必须通过构造函数初始值列表为这些成员提供初值**
```c++
class ConstRef{
public:
	ConstRef(int ii);
private:
	int i;
	const int ci;
	int &ri;
}
```

正确的（显式）始化方式：
```c++
ConstRef::ConstRef(int ii) : i(ii), ci(ii), ri(i) { }
```

### 委托构造函数
一个委托构造函数使用它所属类的其他构造函数执行它自己的初始化过程
和其他构造函数类似，一个委托构造函数也有一个成员初始值和一个函数体，但是成员初始化列表**只有一个唯一地入口**，就是类名本身
```c++
class Sales_data{
public:
	Sales_data(std::string s, unsigned cnt, double price) :  bookNo(s) ，units_sold(cnt) {}
	
	// 委托构造函数
	Sales_data() : Sales_data("", 0) {}
	Sales_data(std::string s) : Sales_data(s, 0) {}
}
```

如果函数体包含代码的话，将先执行这些代码，然后控制权才会交还给委托者的函数体

### 聚合类
聚合类使得用户可以直接访问其成员，并且具有特殊的初始化语法形式。当一个类满足如下条件的时候，我们说它是聚合的：
- 所有成员都是 `public`
- 没有定义任何构造语句
- 没有类内初始值
- 没有基类，也没有 `virtual` 函数

显式地初始化类的对象的成员存在缺点：
- 要求所有的成员都是 `public`
- 将正确的初始化每个对象的每个成员的重任的重任交给了用户并非作者
- 添加或删除一个成员之后，所有初始化语句都需要更新

### 字面值常量类
- 数据成员必须都是字面值类型
- 类必须至少含有一个 `constexpr` 构造函数
- 如果一个数据成员含有类内初始值，则内置类型成员的初始值必须是一条常量表达式；或者如果成员属于某种类类型，则初始值必须使用成员自己的 `constexpr` 函数
- 类必须使用析构函数的默认定义，该成员负责销毁类的对象

#### constexpr 构造函数
P267

## struct 与 class
出于统一编程风格的考虑，当我们希望定义的类所有的成员是 `public` 的时，使用 `struct` ；反之，则使用 `private`

>使用 `class` 和 `struct` 定义类唯一的区别就是默认的访问权限

## 友元
关键字为 `friend`
如果类想把一个函数作为它的友元，只需要添加一条以 `friend` 关键字开始的函数声明语句即可：
```c++
class Sales_data {
	friend Sales_data add(const Sales_data&, const Sales_data&);
	friend std::istream &read(std::istream&, Sales_data&);
	frieng std::ostream &print(std::ostream&, const Sales_data&);
	...
};
```

友元不是类的成员也不受他所在区域访问控制级别的约束
>一般来说，最好是在类的开始或结束前的位置集中声明友元

---
>封装的益处：
>- 确保用户代码不会无意间破坏封装对象的状态
>- 被封装的类的具体实现细节可以随时改变，而无需调整用户级别的代码
---

### 类之间的友元关系
如果一个类指定了友元类，则友元类的成员函数可以访问此类的包括非公有成员在内的所有成员
```c++
class Screen{
	// Screen 将 Window_mgr 指定成它的友元类
	friend class Window_mgr;
}
```

需要注意一点：**友元关系并不存在传递性**（每个类负责控制自己的友元类或友元函数）
>A 是 B 的友元，B 是 C 的友元，但是 A 不能访问 C 中的成员

### 令成员函数作为友元
当把成员函数声明成友元的时候一定要明确指出该成员函数属于哪一个类，想令某个成员作为友元，我们必须组织好程序的结构来满足彼此的关系：
存在 *Screen* 和 *Window_mgr* 两个类，假如要使用 *Window_mgr* 中的 *clear* 来清理屏幕
- 首先定义 *Window_mgr* 类，其中声明 *clear* 函数，但是不能定义它。在 *clear* 使用 *Screen* 的成员之前必须先声明 *Screen*
- 接下来定义 *Screen*，包括对于 *clear* 的友元声明
- 最后定义 *clear* ，此时它才可以使用 *Screen* 中的成员

### 友元声明和作用域
我们仅仅是用声明有缘的类的成员的成员调用该友元函数，它也必须是声明过的
```c++
struct X{
	friend void f() { /* 友元函数可以定义在类的内部 */ }
	X() { f(); }				// 错误：f 没有声明
	void g();
	void h();
}

void X::g() { return f(); }		// 错误：f 没有声明
void f();
void X::h() { return f(); }		// f 现在已被声明在作用域中
```

友元声明的作用是影响访问权限，他并非蹼泳意义上的声明

## 类的其他特性
### 定义一个类型成员
类型成员通常出现在类开始的地方
```c++
class Screen {
public:
	typedef std::string::size_type pos;
private:
	pos cursor = 0;
	pos height = 0, width = 0;
	std::string contents;
};
```

```c++
typedef std::string::size_type pos;
```

等价于
```c++
using pos = std::string::size_t;
```

### 可变数据成员
我们希望在能修改类的某个数据成员，即使是在一个常量成员函数内
关键字为 `mutable` 
一个可变数据成员永远不会是 `const` ，即使他是 `const` 对象。因此，一个常量长远函数可以该百年一个可变成员的值
```c++
class Screen {
public:
	void some_member() const;
private:
	mutable size_t access_ctr;
};

void Screen::some_member() const{
	++access_str;
}
```

### 类数据成员的初始值
我们希望在  `Window_mgr` 类开始时总是拥有一个默认初始化的 `Screen`。在 C++11 新标准中，最好的方式就是把这个处理默认值声明成一个类内初始值
```c++
class Window_mgr {
private:
	std::vector<Screen> screens {Screen(24, 80, '')};
}
```

### 返回 *this 的成员函数
将 `this` 对象作为左值返回，意味着这些函数返回的是对象的本身而并非对象的副本，而且可以将一系列的操作连接成一条表达式：
```c++
myScreen.move(4, 0).set('#');
```

等价于
```c++
myScreen.move(4, 0);
myScreen.set('#');
```

#### 从 const 成员函数返回 *this
一个常量成员函数如果以引用的形式返回 `*this`，那么它的返回类型将是常量引用

#### 基于 const 的重载
因为非常量版本的函数对于常量对象是不可用的，所以我们只能在一个常量对象上调用常量成员函数
```c++
class Screen{
public:
	Screen &display(std::ostream &os){
		do_display(os);
		return *this;
	}
	const Screen &display(std::ostream &os) const{
		do_display(os);
		return *this;
	}
private:
	void do_display(std::ostream &os) const {os << contents;}
};
```

当我们在某个对象上调用 *display* 的时候，该对象是否为 `const` 决定了它调用的版本

>**应当对于公共代码使用私有功能的函数**

### 类类型
#### 类的声明
类的**前向声明**：
```c++
class Screen;
```

它向程序中引入名字 *Screen* 并且指明 *Screen* 是一种类型。对于 *Screen* 来说，在它声明之后定义之前是一种 ***不完全类型***，也就是说，此时已知 *Screen* 是一种类类型，但是不清楚它包含哪些成员

不完全类型只能在很有限的情况下使用：
**可以定义指向这种类型的指针或引用，也可以声明（但是不能定义）以不完全类型作为参数或者返回类型的函数**

## 类的作用域
### 名字查找与类的作用域
名字查找，即寻找与所用名字最匹配的声明的过程
>编译器处理完类中的全部声明后才会处理成员函数的定义

### 用于类成员的名字查找
声明中使用的名字，包括返回类型或者参数列表中使用的名字，都不洗在使用前确保可见。如果某个成员的声明使用了类中尚未出现的名字，则编译器会在**定义该类的作用域中**继续查找

### 类型名要特殊处理
内层作用域可以重新定义外层作用域中的名字，即使在内层作用域中使用过。然而在类中，如果成员使用了外层作用域中的某个名字，并且该名字代表某一类型，则类不能在之后重新定义该名字
>类型名的定义通常出现在类的开始处

### 成员定义中的普通块作用域的名字查找
成员函数中使用的名字按照如下方式进行解析：
- 首先，在成员函数内查找改名字的声明
- 如果在成员函数内没有找到，则在类中继续寻找，这时类的所有成员都可以被考虑
- 如果类内也没有找到，在 **成员函数定义之前** 的作用域继续寻找

### 类作用域之后，在外围的作用域查找
如果编译器在函数和类的作用域中都没有查找到名字。它将接着外围的作用域中查找。如果我们需要外层作用域中的名字，可以**显式地通过作用域运算符来进行请求**：
```c++
int height;
void fcn(int height){
	int fcn_height = ::height;
}
```

## 类的静态成员
[函数Notes](函数Notes.md)
静态成员函数不与任何对象绑定，它们不包含 `this` 指针，并且不能声明成 `const`

### 定义静态成员

- 必须在类的外部定义和初始化每个静态成员
- 静态成员类似于全局变量，静态成员定义在任何函数之外。因此一旦被定义，就将一直存在于程序的整个声明周期之中

### 静态成员类内初始化
通常情况下，不应该类内初始化。然而可以通过提供 `const` 整数类型的类内初始值，不过要求静态成员必须是字面值常量类型的 `constexpr`，初始值必须为常量表达式
```c++
class account{
...
static constexpr int period = 30;
...
}

// 一个不带初始值的静态成员的定义，初始值在类内提供
cosntexpr int account::period;
```

>即使一个常量静态成员在类内被初始化了，依然也需要在类外定义一下该成员

### 静态成员有别于普通成员
- 静态成员可以为不完全类型，而非静态只能声明成它所属类的指针或引用
	```c++
	class bar {
	...
	static bar mem1;
	bar *mem2;
	...
	}
	```
- 可以使用静态成员作为默认实参
	```c++
	class screen {
	public:
		// bkground 表示一个在类中稍后定义的静态成员
		Screen& clear(char = bkground);
	private:
		static const char bkground;
	}
	```