# C 风格字符串
以 `\0` 结尾的都是 C 风格字符串

## C 风格字符串的标准库函数
头文件
```c++
#include<cstring>
```

| 函数 | 解释 |
| :---- | :---- | 
| `strlen(s)` | 返回 s 的长度，**不包括字符串结束符**|
| `srtrcmp(s1, s2)` | 比较 s1 和 s2 是否相同。<br>相等返回 0 ；s1 > s2，返回正数；s1 < s2，返回负数 |
| `strcat(s1, s2)` | 将 s2 连接到 s1 后面，并返回 s1 |
| `strcpy(s1, s2)` | 将 s2 赋值给 s1，并返回 s1|
| `strncat(s1, s2, n)` |将 s2 的前 n 个字符连接到 s1 后面，并返回 s1|
| `strncpy(s1, s2, n)`|将 s2 的前 n 个字符赋值给 s1 ，并返回 s1|

>**注意**：
> - 永远不要忘记字符串结束符 `\0`
> - `strcat` 和 `strcoy` 必须保证第一个实参拥有足够大的空间存放新生成的字符串
> - 使用 `strn` 函数时一定要**时刻记住算上结束符** `\0`
> - 尽可能使用标准库类型 `string`

# 动态数组
>每一个程序在执行的时候都占用一块可用的空间，用于存放动态分配的对象，此空间为程序的**自由存储区**或**堆**

## 定义与初始化
### 定义
```c++
int *pia = new int[10];
```

`new` 返回的是该数组的第一个元素指针，并初始化 pia
- `new` 表达式需要指定**指针类型**以及**方括号中给出的数组维数**
- 在自由存储区创建的数组对象是没有名字的，只能通过地址进行间接访问

### 初始化
- 动态分配数组时，如果元素具有类类型，将使用该类的构造函数实现初始化
- 若为内置类型（e.g `string`），则不会初始化

带值初始化
```c++
// 初始化为0
int *pi = new int[10]();
```

>**注意**：动态数组的元素只能初始化为默认值，而不能像数组一样指定其中一个的值

### const 对象的动态数组
初始化方式
```c++
const int *pci_1 = new const int[100]();
```

若为 `string` 将会调用 默认构造函数
```c++
const string *pci_2 = new const string[100];
```

### 允许动态分配空数组
```c++
size_t n = get_size();
int *p = new int[n];
```

>`size_t`是一种数据相关的无符号类型，它被设计得足够大以便能够内存中任意对象的大小[📇](https://blog.csdn.net/Richard__Ting/article/details/79433814)

在 `new` 中允许创建长度为 0 的动态数组，`new` 依然会返回有效的非零指针。但不允许进行解引用的操作，因为没有指向有效值。唯一可以进行的操作是：*比较运算*

## 空间释放
使用 `delete` 进行空间释放
```c++
delete [] pia;
```

`[]` 是表示释放的是该指针指向的数组，并非是单个对象

# 新旧代码的兼容
## string 与 C 风格字符串
`string` 返回 C 风格字符串

```c++
char str* = st2.c_str();
```

## 数组与 vector
数组初始化 `vector`
```c++
const size_t arr_size = 6;
int int_arr[arr_size] = {0, 1, 2, 3, 4, 5};

vector<int> ivec(int_arr, int_arr + arr_size);
```
