## String
### 初始化
| 语句 | 解释 |
| :---- | :---- | 
| `string s1;` | 默认构造函数（空串）|
| `string s2(s1);` | s2 初始化为 s1 的副本 |
| `string s3("value");` | 初始化为字面值的副本 |
| `string s4(n, 'c');` | 初始化为字符 `c` 的 n 个副本|


> **注意**： 字符串字面值并不等于 string 类型

### string 对象读写
`string` 类型的***输入***操作符需要注意：
- `string` 会读取并忽略开头所有的空白字符
- 当读取字符直到再次遇到空白字符，读取终止

### string 操作
| 方法 | 解释 |
| :---- | :---- | 
| `s.empty()` | 判断 `s` 是否为空串|
| `s.size()` | 返回 `s` 中字符的个数 |
| `s[n]` | 与数组用法相同 |
| `s1 + s2` | 拼接成新的字符串|

#### 关于 size() 的返回值
`size()` 成员返回的不是 `int` 类型，而是 `string::size_type`  类型。书上并没有说明确切的类型，但可以知道它是 `unsigned` 类型

> **注意**：`size()` 的返回变量必为 `string::size_type` 型。
> 而且不要把 `size()` 的返回值赋给一个 `int` 变量

```c++
	string::size_type ix = s.size();
```

### string 对象中字符的处理
头文件 `cctype` 可以对 `string` 字符和  `char` 的值进行处理

| 函数 | 解释 |
| :---- | :---- | 
| `isalnum()` | 如果参数是字母数字，即字母或数字，该函数返回 true|
| `isalpha()` | 如果参数是字母，该函数返回 true |
| `isblank()` | 如果参数是空格或水平制表符，该函数返回 true |
| `iscntrl()` | 如果参数是控制字符，该函数返回 true|
| `isdigit()` | 如果参数是数字（0～9），该函数返回 true|
| `isgraph()` | 如果参数是除空格之外的打印字符，该函数返回 true|
| `isprint()` | 如果参数是打印字符（包括空格），该函数返回 true|
| `ispunct()` | 如果参数是标点符号，该函数返回 true|
| `isspace()` | 如果参数是标准空白字符，如空格、进纸、换行符、回车、<br>水平制表符或者垂直制表符，该函数返回 true|
| `isupper()` | 如果参数是大写字母，该函数返回 true|
| `isxdigit()` | 如果参数是十六进制的数字，即0～9、a~f、A~F，该函数返回 true|
| `tolower()` | 如果参数是大写字符，则返回其小写，否则返回该参数|
| `toupper()` | 如果参数是小写字母，则返回其大写，否则返回该参数|


## vector
`vector` 是一个类模板，格式：
```c++
	vector<T> tmp;
```

> **注意**：对于 `vector` 最有效动态添加数据的方法是先初始化一个空的 `vector` 对象


### 初始化
| 语句 | 解释 |
| :---- | :---- | 
| `vector<T> v1;` | `vector` 保存类型为 T 的对象，默认 v1 为空|
| `vector<T> v2(v1);` | v2 是 v1 的副本 |
| `vector<T> v3(n, i);` | v3 包含 n 个值为 i 的元素 |
| `vector<T> v4(n);` | v4 含有初始化的元素的 n 个副本|

> **关于值初始化**：倘若没有指明元素的初始化的方式，标准库将会自行提供一个元素初始值进行值初始化，具体的值取决于 `vector` 中元素的数据类型

### vector 操作
| 方法 | 解释 |
| :---- | :---- | 
| `v.empty()` | 判断 `v` 是否为空串|
| `v.size()` | 返回 `v` 中元素的个数 |
| `v.push_back(t)` | 在 `v` 末尾增加一个值为 t 的元素 |
| `v[n]` | 与数组用法相同 |

跟 `string` 一样，`vector` 的 `size()` 返回值同样不为 `int`，而是 `vector<T>::size_type`

## 迭代器简介
现代 C++ 更倾向于使用迭代器而不是使用下标

### 容器的 iterator 类型
每个容器都有自己的迭代器类型，如 `vector`:
```c++
	vector<int>::iterator iter;
```

### begin 和 end 操作
每一个容器都定义了一堆命名为 `begin` 和 `end` 的函数，用于返回迭代器
- `begin`：返回迭代器第一个元素
	```
		vector<int>::iterator iter = ivec.begin();
	```

- `end`：返回的迭代器是**指向容器的末端元素的下一个**，并不是指向最后一个元素。通常称为**超出末端迭代器**，表明它指向了一个不存在的元素

> 由 `end` 返回的迭代器并不指向任何一个元素，相反，它只是起到了**哨兵**的作用，表示我们已经处理完该容器中的元素

### 迭代器的自增和解引用运算
迭代器类型可以使用**解引用操作符**来访问迭代器中所指向的元素：
```c++
	*iter = 0;
```

迭代器自增
```c++
	++iter;
```

> **注意**：`end` 返回的迭代器不指向任何元素，所以不能对其进行**解引用**和**自增**

迭代器使用示例
```c++
	for (vector<int>::iterator iter = begin(); iter != ivec.end(); ++iter) {
		cout << *iter << endl;
	}

```

### const_iterator
`const_iterator` 只能用于读取容器中的元素值，但不能改变元素值
**当对 `const_iterator` 解引用的时候会得到 `const` 对象的引用**

> **注意**：`const_iterator` 与 `const` 的 `iterator` 是两个不一样的东西！
>`const` 迭代器初始化：`const vector<int>::iterator cit = begin();`** 一旦被初始化之后，它只能修改它所指向的元素并且不能指向其他的元素**

总之：
- `const_iterator` ：不允许修改元素
- `const vector<int>::iterator` ：不能改变元素指向

### 迭代器的算术操作
- `iter + n` 和 `iter - n` 
	加减的 n 的类型必须为 `size_type` 或 `difference_type` 类型
- `iter1 - iter2` 
	该表达式是用来计算两个迭代器对象的距离，这距离是名为 `difference_type` 的 `signed` 类型的值。（因为可能会产生负数值）
	
> **注意**：任何**改变容器长度的操作都会使现有的迭代器失效**

## 标准库 bitset 类型
使用 bitset 来处理二进制位的有序集
- 头文件：`bitset`

### 初始化
| 语句 | 解释 |
| :---- | :---- | 
| `bitset<n> b;` | b 有 n 位，每位都为 0 |
| `bitset<n> b(u);` | b 是 `unsigned long` 型 u 的一个副本 |
|`bitset<n> b(s);`|b 是 `string` 对象 s 中含有的位串的副本|
|`bitset<n> b(s, pos, n);`|b 是 s 中从位置 pos 开始的 n 个位的副本|

在定义 `bitset` 的时候需要明确 `bitset` 的长度
```c++
	bitset<32> bitvec;
```

在以 0 位开始的位串是*低阶位*，以 31 结束的是*高阶位*

#### 用 unsigned 值初始化 bitset 对象
当使用 `unsigned long` 值做为对象的初始值时，该值将会转化为二进制位模式。
- 如果 `bitset` 类型长度大于 `unsigned long` 的二进制位数，则其余高位全部置为 0 
- 如果小于，则只是用 `unsigned` 值中的低阶位，超出 `bitset` 类型的长度高阶位则会被抛弃

#### 用 string 对象初始化 bitset 对象
当用 `string` 对象初始化 `bitset` 对象时， `string` 对象直接表示为位模式。
- `string` 对象读入位集的顺序是 **从左向右**

```c++
	string strval("1100");
	bitset<32> bitvec4(strval);
```

> **关于从左到右**：`string` 对象和 `bitset` 对象之间是**反向转化**的，即 `string` 对象的**最大下标**对应 `bitset` 对象的**低阶位**。

### bitset 对象上的操作
| 方法 | 解释 |
| :---- | :---- | 
|`b.any()`|b 中是否存在置为 1 的二进制位？|
|`b.none()`|b 中不存在置为 1 的二进制位吗？|
|`b.count()`|b 中置为 1 的二进制位的个数|
|`b.size()`|b 中二进制位的个数|
|`b[pos]`|访问 b 中在 pos 处的二进制位|
|`b.test(pos)`|b 中在 pos 处的二进制位是否为 1 ？|
|`b.set()`|把 b 中所有二进制位都置为 1|
|`b.set(pos)`|把 b 中在 pos 处的二进制位置为 1 |
|`b.reset()`|把 b 中所有二进制位都置为 0|
|`b.reset(pos)`|把 b 中在 pos 处的二进制位置为 0|
|`b.flip()`|把 b 中所有二进制位逐位取反|
|`b.flip(pos)`|把 b 中在 pos 处的二进制位取反|
|`b.to_ulong()`|用 b 中同样的二进制位返回一个 `unsigned long` 值|
|`os << b`|把 b 中的位集输出到 `os` 流|

- `count()` 和 `size()` 返回的值的类型全部为 `size_t`（定义在 `cstddef` 中）
- `to_long()` 操作仅当 `bitset` 类型长度小于或等于 `unsigned long` 长度时，才可以使用 `to_long()` 操作。
- `to_long()` 操作主要用于把 `bitset` 对象转到 C 风格或标准 C++ 之前风格的程序上