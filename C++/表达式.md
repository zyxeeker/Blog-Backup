## 位操作符
| 操作符 | 功能 | 用法 |
| :---- | :---- | :---- |
| `~` | 位求反|`~expr`|
| `<<` | 左移 | `expr1 << expr2`|
| `>>` | 右移 |`expr1 >> expr2`|
| `&` | 位与 | `expr1 & expr2` |
| `^` | 位异或 | `expr1 ^ expr2` |
| `\|`| 位或 | `expr1 \| expr2`|

>对于操作符，由于系统不能确保如何处理其操作数的符号位，所以**强烈**建议使用 `unsigned` *整形*操作数

取反操作
```c++
	unsigned char bits = 0227;
	bits = ~bits;
```

左移右移
```c++
	// 左移
	bits << 1;
	bits << 2;
	// 右移
	bits >> 3;
```

>**注意**：移位操作的 *右操作数* 必须小于操作数的 *位数*

位与、位异或、位或操作都需要**两个整形操作数**

位异或：在每个位的位置，如果两个操作数对应的只有一个为 1 ，则操作结果中该位为 1，否则为 0

### bitset 对象或整型值的使用
[bitset 定义与相关用法](标准库类型.md)

书上的例子：
假设某个老师班上有 30 个学生，每个星期在班上做一次测验，只有及格与不及格两种成绩，对于每个学生用一个二进制位来记录一次测试及不及格

#### 使用 bitset
使用 `bitset` 或整数值来代表一次测验：
```c++
	// 初始化默认所有位都为 0
	bitset<30> bigset_quiz1;
	
	// 假如老师检查第 27 个学生的成绩合格
	bitset_quiz1.set(27);
	
	// 加入老师复查发现第27 个学生不合格
	bitset_quiz1.reset(27);
```

最后通过以下代码获知第 27 位同学的成绩是否合格
```c++
	bool status;
	status = bitset_quiz1[27];
```

#### 使用整数型
>`unsigned long` 在所有机器上至少拥有 32 位的长度

```c++
	unsigned long int_quiz1 = 0;
	
	// 假如第 27 个学生的成绩合格
	int_quiz1 |= 1UL<<27;
	
	// 加入老师复查发现第27 个学生不合格
	int_quiz1 &= ~(1UL<<27);
```

最后通过以下代码获知第 27 位同学的成绩是否合格
```c++
	bool status;
	status = int_quiz1 & (1UL<<27);
```

>`1UL`：表示无符号的长整型 1
>`0UL`：表示无符号的长整型 0

## 关于自增和自减
### 1. 只有在必要的时候才使用后置操作符
`++i` 比 `i++` 操作所需做的工作更少，因为 `i++` 需要先保存操作数原来的值，以便返回未加 1 之前的值操作的结果。所以应当只有在必要的时候才使用后置操作符

### 2. 简洁
像 `*iter++` 这类令人困惑的表达式，有经验的c++程序员非常重视简练，他们更喜欢这么写
```c++
	cout << *iter++ << endl;
```

等价于：
```c++
	cout << *iter << endl;
	*iter++;
```

## new 和 delete 表达式
[动态数组](C%20风格字符串与动态数组.md)

### 动态创建对象初始化
```c++
int *pi = new int(1024);				// pi = 1024
string *ps = new string(10, '9');		// *ps = "9999999999"
```

### 动态创建对象默认初始化
无论程序是明确地不初始化还是要求进行值初始化，都会调用默认构造函数进行初始化
```c++
int *pi = new int();
string *ps = new string();
```

### 耗尽内存
尽管现在的内存十分的大，但是自由存储区总有可能会被耗尽。返回值为 `bad_alloc`

### 在 delete 之后，重设指针的值
在 `delete` 指针后，该指针会变为 **悬垂指针**。**悬垂指针**指向曾经存放对象的内存，但该对象已经不存在了。*悬垂指针往往会导致程序错误*
**处理方式：在 `delete` 掉指针后应该立即将指针置为 0**

### const 对象动态分配与回收
C++允许动态创建 `const` 对象
```c++
	const int *pci = new const int(1024);
```

与其他常量一样，动态创建的 `const` 对象必须在创建的时候初始化，并且一旦初始化，其值就不再改变
同样，使用 `delete` 回收空间

## 类型转换
### 何时会发生隐式类型转换
- 在混合类型的表达式中，其操作数被转换为相同的类型
- 在作条件表达式被转换为 `bool` 类型
- 用一表达式初始化某个变量，或将一表达式赋值给某个变量，则该表达式被转换为该变量类型

### 算术转换
算术转换规定操作数应该转换为表达式中的最宽的类型

#### 有符号与无符号类型之间的转换
 `unsigned` 操作数的转换依赖于机器整形的相对大小，因此这类转换本质上依赖于机器

`unsigned short` 与 `int` ，如果 `int` 型足够表示所有 `unsigned short` 的值，则将 `unsigned short` 转化为 `int` ，否则将两个操作数均转为 `unsigned int` 型；同理，`long` 与 `unsigned int` 也一样

对于包含 `signed` 和 `unsigned int` 型的表达式，表达式会将 `signed` 型数值转化为 `unsigned` 型。比如，比较 `int` 和 `unsigned int` 型的简单变量，系统首先会将 `int` 型数值转化为 `unsigned int` 型，如果为负数则会***是对该类型的取值个数求模后的值***

### 隐式转换
#### 指针转换
在使用数组的时候，大多数情况下指针会自动转化为第一个元素的指针；不将数组转换为指针的例外情况有：
- 数组用作取地址（`&`）操作符的操作数或 `sizeof` 操作符的操作数时
- 数组对数组的引用初始化时

#### 转化为 bool 类型

#### 算术类型与 bool 类型的转换
0 转化为 `false` ，其他值转化为 `true`

#### 转换与枚举类型
C++ 自动将枚举类型的对象或枚举成员转化为整型。枚举对象或枚举成员至少提升为 `int` 型，如果 `int` 型无法表示枚举成员的最大值，则提升到能表示枚举成员值的、大于 `int` 型的最小类型

#### 转换为 const 对象
当使用非 `const`  对象初始化 `const` 对象的引用时，系统将非 `const` 对象转化为 `const` 对象。此外，还可以将非 `const` 对象的地址转化为只想相关 `const` 类型的指针：
```c++
	int i;
	const int cj = 0;
	const int &j = i;
	const int *p = &ci;
```

#### 由标准库定义的转换
类类型可以定义由编译器自动执行的类型转换。比如，从 `istream` 中读取数据，并将此表达式作为 `while` 循环的条件：
```c++
	string s;
	while(cin >>s)
```

这里隐式使用了IO标准库定义的类型转换。在此条件中，如果尝试成功，则循环条件成立；如果最后一次尝试失败，则跳出循环。

### 显示转换
显示转换也称为强制转换
>**注意**：有时候需要强制转换类型，但是本质上是十分危险的

### 何时需要强制类型转换
当需要覆盖同城的标准转换，所以需要显示转换
，比如
```c++
	double dval;
	int ival;
	ival *= dval;
```

上面代码最后的操作是将 `double` 型结果转换为 `int` 型，倘若要去掉这个不必要的转换，则可以改成下面的代码

```c++
	ival *= static_cast<int>(dval);
```
另一种情况是：可能存在多种转换，组要一种特定的类型进行转换（第14章）

命名强制转换的格式：
```
	cast-name<type>(experssion);
```
cast-name 为`const_cast`，`static_cast` 和 `reinterpret_cast`；type 为转换的目标类型；expression 违背强制转换的值

强制转换操作符有下列几个：

#### dynamic_cast
支持运行时识别指针或引用所指向的对象（18.2节）

#### const_cast
转换表达式的 `const` 性质。假如有函数 `string_cpy` ，只有唯一的参数，位 `char*`  类型，我们只对该函数只读不写。在访问该函数时，最好的选择是修改它让它接受 `const char*` 类型的参数。如果不行，可通过 `const_char` 用一个 `const` 值调用 `string_copy` 函数
```c++
	const char *pc_str;
	char *pc = string_copy(const_cast<char*>(pc_str));
```

#### static_cast
编译器隐式执行的任何类型转换都可以由 `static_cast` 显式完成
```c++
	double d = 97.0;
	char ch = static_cast<char>(d);
```

当需要讲一个较大的算术类型赋值给较小的类型时，使用强制转换十分有效（*相当于告诉编译器：我们知道并且不关心潜在的精度损失*）。
				
如果编译器不提供自动转换，使用 `static_cast` 将会很有用。例如，下面的程序使用 `static_cast` 来找回存放在 `void*` 指针中的值
```c++
	void* p = &d;
	double *dp = static_cast<double*>(p);
```

可通过 `static_cast` 将存放在 `void*` 中的指针值强制转换为原来的指针类型

#### reinterpret_cast
`reinterpret_cast` 通常为操作数的位模式提供较低层次的重新解释
```c++
	int *ip;
	char *pc = reinterpret_cast<char*>(ip);
```

必须永远记得 pc 所指向的真实对象的类型其实是 `int` 型，而并非字符数组。任何假设 pc 是普通字符指针的应用，都会带来运行时的错误。

>**注意**：应当尽量避免使用强制转换。每次使用强制转换之前，程序员应当仔细靠考虑是否还有其他不同的方法可以达到同一目的。如果非强制转化不可，则应当限制转换至的作用域，并且记录所有假定设计的类型，这样能够减少发生错误的机会

### 旧式强制转化类型
旧式强制转化符号有些列两种形式：
```c++
	type (expr);
	(type) expr;
```

旧式转换提供了与各自对应的命名强制转换一样的功能。如果前两种强制转换（`static_cast`  和 `const_cast`）均不合法，则旧式强制转换执行 `reinterpret_cast` 功能

