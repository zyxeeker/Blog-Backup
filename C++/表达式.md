## 位操作符
| 操作符 | 功能 | 用法 |
| :---- | :---- | :---- |
| `~` | 位求反|`~expr`|
| `<<` | 左移 | `expr1 << expr2`|
| `>>` | 右移 |`expr1 >> expr2`|
| `&` | 位与 | `expr1 & expr2` |
| `^` | 位异或 | `expr1 ^ expr2` |
| `\|`| 位或 | `expr1 \| expr2`|

>对于操作符，由于系统不能确保如何处理其操作数的符号位，所以**强烈**建议使用 `unsigned` *整形*操作数

取反操作
```c++
	unsigned char bits = 0227;
	bits = ~bits;
```

左移右移
```c++
	// 左移
	bits << 1;
	bits << 2;
	// 右移
	bits >> 3;
```

>**注意**：移位操作的 *右操作数* 必须小于操作数的 *位数*

位与、位异或、位或操作都需要**两个整形操作数**

位异或：在每个位的位置，如果两个操作数对应的只有一个为 1 ，则操作结果中该位为 1，否则为 0

### bitset 对象或整型值的使用
[bitset 定义与相关用法](标准库类型.md)

书上的例子：
假设某个老师班上有 30 个学生，每个星期在班上做一次测验，只有及格与不及格两种成绩，对于每个学生用一个二进制位来记录一次测试及不及格

#### 使用 bitset
使用 `bitset` 或整数值来代表一次测验：
```c++
	// 初始化默认所有位都为 0
	bitset<30> bigset_quiz1;
	
	// 假如老师检查第 27 个学生的成绩合格
	bitset_quiz1.set(27);
	
	// 加入老师复查发现第27 个学生不合格
	bitset_quiz1.reset(27);
```

最后通过以下代码获知第 27 位同学的成绩是否合格
```c++
	bool status;
	status = bitset_quiz1[27];
```

#### 使用整数型
>`unsigned long` 在所有机器上至少拥有 32 位的长度

```c++
	unsigned long int_quiz1 = 0;
	
	// 假如第 27 个学生的成绩合格
	int_quiz1 |= 1UL<<27;
	
	// 加入老师复查发现第27 个学生不合格
	int_quiz1 &= ~(1UL<<27);
```

最后通过以下代码获知第 27 位同学的成绩是否合格
```c++
	bool status;
	status = int_quiz1 & (1UL<<27);
```

>`1UL`：表示无符号的长整型 1
>`0UL`：表示无符号的长整型 0

## 关于自增和自减
### 1. 只有在必要的时候才使用后置操作符
`++i` 比 `i++` 操作所需做的工作更少，因为 `i++` 需要先保存操作数原来的值，以便返回未加 1 之前的值操作的结果。所以应当只有在必要的时候才使用后置操作符

### 2. 简洁
像 `*iter++` 这类令人困惑的表达式，有经验的c++程序员非常重视简练，他们更喜欢这么写
```c++
	cout << *iter++ << endl;
```

等价于：
```c++
	cout << *iter << endl;
	*iter++;
```

## new 和 delete 表达式
[动态数组](C%20风格字符串与动态数组.md)

### 动态创建对象初始化
```c++
int *pi = new int(1024);				// pi = 1024
string *ps = new string(10, '9');		// *ps = "9999999999"
```

### 动态创建对象默认初始化
无论程序是明确地不初始化还是要求进行值初始化，都会调用默认构造函数进行初始化
```c++
int *pi = new int();
string *ps = new string();
```

### 耗尽内存
尽管现在的内存十分的大，但是自由存储区总有可能会被耗尽。返回值为 `bad_alloc`

### 在 delete 之后，重设指针的值
在 `delete` 指针后，该指针会变为 **悬垂指针**。**悬垂指针**指向曾经存放对象的内存，但该对象已经不存在了。*悬垂指针往往会导致程序错误*
**处理方式：在 `delete` 掉指针后应该立即将指针置为 0**

### const 对象动态分配与回收
C++允许动态创建 `const` 对象
```c++
	const int *pci = new const int(1024);
```

与其他常量一样，动态创建的 `const` 对象必须在创建的时候初始化，并且一旦初始化，其值就不再改变
同样，使用 `delete` 回收空间

