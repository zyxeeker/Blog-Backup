## Notes
函数的声明应放在头文件中，在函数中局部声明名字将屏蔽在全局作用域内声明的同名名字

### 传递指向指针的引用
示例：
- 交换函数 ptrswap：
```c++
void ptrswap(int *&i, int *&j){
	int *tmp = v2;
	v2 = v1;
	v1 = tmp;
}
```

- 主函数：
```c++
int main(){
	int i = 10;
	int j = 20;
	int *pi = &i;
	iny *pj = &j;
	ptrswap(pi, pj);
}
```

### 通过引用传递数组
```c++
void printValues(int (&arr)[10]) {...}
```

>**注意**：*&arr* 两边的括号是必须的，因为下标操作具有更高的优先级

### 多维数组的传递
两种形式：
```c++
// 括号必须存在
void printValues(int (martix*)[10]) {...}

void printValues(int martix[][10]) {...}
```

### 防止操作导致数组越界
有三种方式防止数组越界：
#### 1. 使用标准库规范
传递指向**数组第一个**和**最后一个元素下一个位置的指针**。（相当于 `vector` 的 `begin` 和 `end`）
```c++
void printValues(const int *beg, const int *end) {...}
```

#### 2.显示传递表示数组大小的形参
将数组的大小作为形参传递到函数之中

#### 3. 放置标记
类似于 C 风格字符串

### 关于 main
#### 处理命令行选项
```c++
int main(int argc, char *argv[]) {...}
```

或者
```c++
int main(int argc, char **argv) {...}
```

*argc* 用于传递该数组中字符串的个数，*argc* 是一个 C 风格字符串数组

假设我们主函数位于名为 *prog* 的可执行文件中，可将如下实参选项传递给程序：
```
prog -d -o ofile data0
```

*main* 中获得数据如下：
```c++
argv[0] = "prog";
argv[1] = "-d";
argv[2] = "-o"
argv[3] = "ofile";
argv[4] = "data0";
```

### 返回引用
当函数返回引用类型时，没有复制返回值，而是返回对象的本身。
```c++
const string &shorterString(const string &s1, const string &s2) {
	return s1.size() < s2.size() ? s1 : s2;
}
```

此时函数返回的是两个 `string` 类型形参中较短的那个字符串的**引用**

>**注意**：千万不能返回局部对象的引用！！！

### 引用返回左值
返回引用的函数返回一个左值
```c++
char &get_val(string &str, string::size_type ix) {
	return str[is];
}

int main() {
	string s("a value");
	cout << s << endl;
	get_val(s, 0) = 'A';
	
	cout << s << endl;
	return 0;
}
```

如果不希望医用返回值被修改，返回值应该声明为 `const`:
```c++
const char &get_val(....
```

>**注意**：同样，千万不要返回指向局部对象的指针

### 静态局部对象
 一个变量如果位于函数的作用域内，但生命周期却阔约了这个函数的多次调用，则应该即将这样的对象定义为 `static`
 
 `static` **局部对象**确保不迟于在程序执行流程第一次经过该对象的定义语句进行初始化。这种对象一旦被创建，在程序结束之前都不会被撤销掉
 
 ### 内联函数
 ```c++
const string &shorterString(const string &s1, const string &s2) {
	return s1.size() < s2.size() ? s1 : s2;
}
```

为这样的小操作定义一个这样的函数的好处是：
- 更容易阅读和理解函数的调用
- 更方便修改
- 使用函数可以确保统一的行为，每个测试都保证以相同的方式实现
- 函数可以重用，不必为其它应用重写代码

但是将 *shortString* 写成函数也有缺点：**调用函数比求解等价表达式要慢得多**。在大多数机器上，调用函数都要做很多的工作：
1. 调用前要先保存寄存器，并在返回的时候恢复；
2. 复制实参；
3. 程序还必须转向一个新位置执行

#### 1. 内联函数避免函数调用开销
将函数指定为内联函数，则它将在程序中每个调用点上“内联”的展开。假设将 *shortString* 定义为内联函数，则调用：
```c++
cout << shortString(s1, s2) << endl;
```

在编译时将展开为：
```c++
cout << s1.size() < s2.size() ? s1 : s2 << endl;
```

关键字为 `inline`
一般来说，内联机制适用于优化小的、只有几行而且经常被调用的函数。大多数编译器都不支持递归函数的内联

#### 2. 把内敛函数放入头文件
>内联函数应该在头文件中定义，这一点不同于其他函数

把内联函数的定义放在头文件中，可以确保在调用函数时所使用的定义是相同的，并且保证在调用点该函数的定义对编译器可见

### 类的成员函数
#### this 指针
`static` 成员不含有 `this` 指针

#### const 成员函数（常量成员函数）
跟在成员函数后面的 `const` 改变了 `this` 形参的类型。`this` 将会变成指向当前对象 `const` 类类型的指针，例如：
```c++
bool Sales_item::same_isbn(const Sales_item *const this, const Sales_item &rhs) const {
	return (this->isbn == rhs.isbn);
}
```

该函数体内的 `this` 等价于 `const Sales_item *const this`

>**注意**：`const` 对象、指向 `const` 对象的指针或引用只能用于调用其 `const` 成员函数，如果尝试是圆通他们来调用非 `const` 成员函数，则是错误的


### 重载函数
有如下重载函数的集合
```c++
void f();
void f(int);
void f(int, int);
void f(double, double = 3.14);
```

重载函数会寻找最佳匹配（如果有的话）
1. 确定候选函数：确定该调用所考虑的函数合集，候选函数是与被调用函数同名的函数，并且在调用点上，它的声明可见
2. 选择可行函数：可行函数需要满足两个条件：
	1. 函数的形参个数与被调用的实参个数相同
	2. 每一个实参的类型必须与对应形参的类型匹配，或者隐式转换为对应的形参类型

> 如果没有找到可行函数，则该调用错误

3. 寻找最佳匹配（如果有的话）

举例：对于 `f(5.6)` 有两个可行函数：`f(int)` 和 `f(double, double = 3.14)`

#### 含有多个形参的重载的确定
如果函数调用使用了两个或两个以上的显式实参，则函数匹配会更加的复杂
举例：
```c++
f(42, 2.56);
```

本例中可行函数为 `f(int, int)` 和 `f(double, double)`
如果有且仅有一个函数满足下列的条件，则匹配成功：
1. 其每个实参的匹配都不劣于其他可行函数需要的匹配（通过内置转换的匹配 *劣于* 精确匹配）
2. 至少有一个实参的匹配优于其他可行函数的匹配

分析一下匹配步骤：
- 首先分析第一个实参，发现  `f(int, int)` 匹配精确。如果与第二个函数进行匹配，则需要转换类型。所以，如果只考虑的一个形参，那么第一个函数比第二个函数匹配更佳
- 分析第二个参数，我们会发现第二个函数为实参 *2.56* 提供了精确的匹配。而第一个函数需要转换类型。所以，只考虑第二个形参的话，函数 `f(double, double)` 匹配更佳

因此，这个调用有二义性：**每个可行函数都对函数调用的一个实参实现更好的匹配**。编译器将会产生错误。解决二义性，需要显式转换：
```c++
f(static_cast<double>(42), 2.56);
f(42, static_cast<int>(2.56));
```

>**注意**：在实际应用中，调用重载函数时应该尽量避免对实参做强制类型转换：需要使用强制类型转换意味着设计的形参集合并不合理

### 实参类型转换
为了确定最佳的匹配，编译器将实参类型到相应形参类型的转换划分等级。划分等级以降序排列如下：
1. 精确匹配
2. 通过类型提升实现的匹配 [🎴](表达式.md)
3. 通过标准转换实现的匹配 [🎴](表达式.md)
4. 通过类类型转换实现的匹配

#### 1. 需要类信号提升或转换的匹配
类型提升或转换适用于实参类型可通过某种标准转换提升或转换为适当的形参类型的情况
必须注意的一个 **重点** ：较小的整形提升为 `int` 型。对于人任意整形的实参值， `int` 型版本都优于 `short` 型版本的最佳匹配，即使从形式上来看 `short` 型版本的匹配更佳
```c++
void ff(int);
void ff(short);
ff('a');
```

字符字面值是 `char` 类型，`char` 型可以提升为 `int` 型。虽然 `char` 型可以转换为 `short` 型，但是需要类型转换的匹配 *劣于* 需要类型提升的匹配。结果应将该调用解释为 `ff(int)` 的调用

#### 参数匹配和枚举类型
在使用枚举类型形象俺的重载函数时，由于不同枚举类型的枚举常量值不相同，在函数重载的过程中，不同的枚举类型会具有完全不同的行为。其枚举成员决定了它们提升的类型，而所提升的类型依赖于机器

#### 重载与 const 形参
>仅当形参是引用或指针时，形参是否为 const 才有影响

可以与函数的引用形参是指向 `const` 对象还是指向非 `const` 对象，实现函数重载。将引用定义为 `const` 来重载函数是合法的，以为编译器可以根据实参是否为 `const` 确定调用哪一个函数

- 如果形参是普通引用，则不能将 `const` 对象传递给这个形参。如果传递了 `const` 对象，则只有带 `const` 引用形参的版本才是该调用的可行函数
- 如果传递的是非 `const` 对象，则上述任意一种函数皆可行。非 `const` 对象既可用于初始化 `const` 引用，也可用于非 `const` 引用。但是，将 `const` 引用初始化为非 `const` 对象，而非 `const` 形参的初始化则是精确匹配

对于指针形参也同理
- 可将 `const` 对象的地址值只传递给带有指向 `const` 对象的指针形参的函数
- 也可以将指向非 `const` 对象的指针传递给函数的 `const` 或非 `const` 类型的指针形参

如果实参是 `const` 对象，则调用带有 `const*` 类型形参的函数；否则，如果是参不是 `const` 对象，则将调用带有普通指针形参的函数

### 指向函数的指针
函数指针是指向函数而非指向对象的指针。想其他指针一样，函数指针也指向某个特定的类型。函数类型由其返回类型以及形参表确定，而与函数名无关：
```c++
bool (*pf) (const string &, const string &);
```

>**注意**：必须带有括号，如果没有括号将会返回返回类型的指针

#### 1. 用 typedef 简化函数指针的定义
```c++
typedef bool (*cmpFcn) (const string &, const string &);
```

该定义表示 *cmpFcn* 是一种指向函数的指针类型的名字。该指针类型为 “指向返回 `bool` 类型并带有两个 `const string`  引用形参的函数的指针”。再有使用这种函数指针类型时，只需要直接使用 *cmpFcn* 即可

#### 2. 指向函数的指针的初始化和赋值
在引用函数名但又没有调用该函数时，函数名将被自动解释为指向函数的指针。
>**注意**：函数指针只能通过同类型的函数或函数指针或 0 值常量表达式进行初始化或赋值
>0 表示该指针不指向任何函数
>指向不同函数类型的指针值减不存在转换！！

```c++
bool lengthCompare(const string &, const string &);
cmpFcn pf1 = 0;
cmpFcn pf2 = lengthCompare;

pf1 = lengthCompare;
pf2 = pf1;
```

此时，直接引用函数名等i下雨在函数名上应用取地址操作符：
```c++
cmpFcn pf1 = lengthCompare;
cmpFcn pf2 = &lengthCompare;
```

#### 3. 通过指针调用函数
指向函数的指针可用于调用它指向的函数。可以不需要使用解引用操作符，直接通过指针调用函数：
```c++
cmpFcn pf = lengthCompare;
lengthCompare("hi", "bye");
pf("hi", "bye");
(*pf*)("hi", "bye");
```

>**注意**：如果指向函数没有初始化，或者具有 0 值，则指针不能在函数调用中使用！
>只有当指针初始化，或被赋值为指向某个函数，方能安全调用函数

#### 4.函数指针形参
函数的形参可以是指向函数的指针。这种形参可以用下面两种方式编写：
```c++
void userBigger(const string &, const string &, bool(const string &,const string &));

void userBigger(const string &, const string &, bool (*)(const string &,const string &));
```

#### 5. 返回指向函数的指针
函数可以返回指向函数的指针，但是，正确写出这种返回类型相当不容易：
```c++
int (*ff(int)) (int*, int);
```

>阅读函数指针声明的最佳方法是从声明的名字开始由里向外理解

*ff(int)* 是一个函数，它带有一个 `int` 形的形参。该函数返回 
```c++
int (*)(int*, int);
```

它是一个指向函数的指针，所指向的函数返回 `int` 型并带有 `int*` 和 `int` 两个形参
使用 `typedef` 可以是该定义更加易懂：
```c++
typedef int (*PF)(int*, int);
PF ff(int);
```

>允许将形参定义为函数类型，但函数的返回类型必须是指向函数的指针，而不能是函数

#### 6. 指向重载函数的指针
C++ 中允许使用函数指针指向重载的函数，**并且指针的类型必须于重载函数的一个版本精确匹配！**
```c++
void ff(vector<double>);
void ff(int);

void (*pf1) (int) = &ff;
```