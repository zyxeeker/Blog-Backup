## 标准输入输出
`cin` 与`cout`（略过）
### 标准错误流
`cerr` ：通常输出警告和错误信息，`cerr`不经过缓冲区，直接向显示器输出信息
`clog` ：用于产生程序执行的一般信息，`clog`中的信息存放在缓冲区，缓冲区满或者遇到`endl`时才输出（`endl` 会刷新缓冲区，通过刷新缓冲区，用户可以立即看到写入到流中的输出）

## GNU 命令


## 预处理器
### 头文件保护符
头文件保护符用于避免在已经见到头文件的情况下重新处理该文件内容

### 避免多重包含
```c++
#ifndef XXXX_H
#define XXXX_H
...
#endif
```

如果 `XXXX_H` 被首次引用，那么 `ifndef` 则会被置为 `True`，然后执行定义的内容；否则会被置为 `False` ，然后跳到 `endif` 并执行后面的部分

## 是用预处理器进行调试
程序所包含的调试代码仅在开发过程中执行。当应用程序已经完成，并且准备提交时就会将调试代码关闭
可使用 `NDEBUG` 预处理变量实现有条件的调试代码：
```c++
	int main(){
		#ifndef NDEBUG
		cerr << "strating main..." <<endl;
		#endif
		...
	}
```

如果 `NDEBUG` 未定义，那么程序就会将信息写道 `cerr` 中。如果已定义，则会跳过它们之间的代码

大多数编译器都提供定义 `NDEBUG` 的命令选项：
```
$ CC -NDEBUG main.c
```

这样相当于在 main.c 的开头提供了 `#define NDEBUG` 预处理命令

预处理还定义了其余四种在调试中非常有用的常量：

| 常量 | 功能 |
| :---- | :---- |
| `__FILE__` | 文件名 |
| `__LINE__` | 当前行号 |
| `__TIME__` | 文件被编译的时间 |
| `__DATE__` | 文件被编译的日期 |

直接用于输出即可
另一个常见的调试技术是使用 `NDEBUG` 预处理变量以及 `assert（断言）`  *预处理宏*
`assert` 定义在头文件 `<cassert>` 中
*预处理宏*的使用：
```c++
	assert(exper)
```

只要 `NDEBUG` 未定义，`assert` 宏就求解条件表达式 *exper*，如果结果为 `false`，`assert` 输出信息并终止程序执行，如果为 `true` ，则不会做出操作

与异常不同的是，使用 `assert` 是来测试 “不可能发生” 的条件。例如，对于处理输入文本的程序，可以预测全部给出的单词都比指定的阈值长。那么程序可以包含一个这样的语句：
```c++
	assert(word.size() > threshold);
```

在测试中，`assert` 等效于检验数据是否总是具有预期的大小。一旦开发和测试工作完成，程序就已经建立好，并且定义了 `NDEBUG`。在成品代码中，`assert` 不语句不做任何工作，不会有任何运行时的代价

>**注意**：`assert` 只用于测试检查并不能代替逻辑检查，也不能代替对程序可能产生的错误检测